/* REXX    FAMTREE    Aids in entering data regarding family
                      relationships and personal data (birthdate,
                      marriage, etc.)
           This uses a FT-type table generated by TBLGEN from AAMSTR.
              Table type FT is defined as:
.          KEYS(FTSEQ)
.          NAMES(FTSEQL FTNAME FTBIRTH FTDEATH FTSPOUSE FTWEDDT FTTEXT,
                 FTSEQ2 FTSPBD FTSPDD FTEMAIL FTSPEML )
.          A special row with FTSEQ (key) '3f'x is used to store an
           extension variable, FTLASTUP, holding the date-of-last-update
           in the form (dd mmm ccyy).  Column FTSEQ2 exists so that a
           range of values (A to Z) can be selected.  On any given row,
           it must be equal to FTSEQ.
.          If requested, will produce HTML as a series of unordered
           lists showing children under their parents, and prefaced and
           trailed by framing HTML.

           Use '(routine name)  ?' for HELP-text.

   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|
   |                                                                 |
   |          WARNING: EMBEDDED COMPONENTS.                          |
   |                      See text following TOOLKIT_INIT            |
   |                                                                 |
   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|

           Written by Frank Clarke  rexxhead@yahoo.com 20210513

     Impact Analysis
.    SYSEXEC   ADDROOT  (related)
.    SYSEXEC   BRTHDAYS (related)
.    SYSEXEC   DFLTTLIB
.    SYSEXEC   FLTTBL
.    SYSEXEC   FTIMPORT (related)
.    SYSEXEC   LA
.    SYSEXEC   REORDER  (related)
.    SYSEXEC   SHUFFLE  (related)
.    SYSEXEC   TBCOPY
.    SYSEXEC   TBLGEN
.    SYSEXEC   TRAPOUT

     Modification History
     20211208 fxc add spouse birthdate/deathdate and emails;
     20230101 fxc recognize ALL fields for updates;
     20230605 fxc clean-up;
     20230614 fxc switch to PO FAMTREE.HTML(family);
     20230615 fxc hard-code epilog text; use new FAMTREE.PROLOG.HTML;
     20230723 fxc modernize logging;
     20230729 fxc clip long lines;
     20230829 fxc fixed NOVAL;
     20230908 fxc set log lrecl to 255;
     20230911 fxc use ZUP/ZCONT in HELP panels;
     20231222 fxc save log if error;
     20231223 fxc set stats on HTML dataset when created;
     20240305 fxc align panel names;
     20240308 fxc chg dollar-sign to @ everywhere;
     20240403 fxc moved <tblnm> from <opts> to <parms>; adjusted
                  HELP-text accordingly;
     20240404 fxc changed tutorial to scrollable area;
     20240415 fxc DUMP_QUEUE quiet;
     20240423 fxc corrected HELP text; use DFLTTLIB to set
                  ISPTLIB/ISPTABL;
     20240817 fxc housekeeping;
     20250112 fxc fix HELP;
     20250206 fxc allow INDENT and DEINDENT to show (or not)
                  indentation of names on the primary selection panel;

*/ arg argline
address TSO                            /* REXXSKEL ver.20210402      */
arg parms "((" opts

signal on syntax
signal on novalue

call TOOLKIT_INIT                      /* conventional start-up     -*/
rc = Trace("O"); rc = Trace(tv)
info   = parms                         /* to enable parsing          */

call A_INIT                            /*                           -*/
if sw.0Flatten then,
   call U_DUMP_TBL                     /*                           -*/
else,
   call I_ISPF_FUNCS                   /*                           -*/

if sw.0KeepLog | sw.0Error_found then,
   call ZB_SAVELOG                     /*                           -*/

if \sw.nested then call DUMP_QUEUE 'quiet' /*                       -*/
exit                                   /*@ FAMTREE                   */
/*
.  ----------------------------------------------------------------- */
A_INIT:                                /*@                           */
   if branch then call BRANCH
   address TSO

   sw.0KeepLog   = SWITCH("LOG")       /* retain the log file       -*/
   sw.0MakeHTML  = SWITCH("HTML")      /* build a webpage insert    -*/
   sw.0Flatten   = SWITCH("FLATTEN")   /* produce flat file at end  -*/
   logpref = "("Branch( "ID" )")"
   parse value info      with ,
               @tn@  info
   if @tn@ = ""        then do         /* Not specified!             */
      helpmsg = logpref "-- <tblnm> must be specified."
      call HELP                        /* ...and don't come back!    */
      end

   if Space(isptlib isptabl,1) = '' then do
      isptlib  = DFLTTLIB( @tn@ )
      isptlib  = "'"isptlib"'"         /* add quotes                 */
      isptabl  = isptlib
      end

   if sw.0Flatten then return          /* we're done                 */

   exposevars  = Space(,
           " @tn@ dfltsort ftseq ftseql ftseq2 keynames ralph temp",
           " isptlib block.   ",
           " ftspcr tidx varnames ",1)

   parse value '41'x   "0" with,
               ftspcr  tidx   disptbl  sel   block.  .
   openmode.   = "NOWRITE"
   openmode.0  = "WRITE"
   alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
   ralph = Reverse(alpha)

   call AA_SETUP_LOG                   /*                           -*/
   logpref = "("Branch( "ID" )")"
   call ZL_LOGMSG( logpref  "ISPTLIB set to" isptlib )
   call ZL_LOGMSG( logpref  "ISPTABL set to" isptabl )
   call ZL_LOGMSG( logpref  "USETBL (@tn@) set to" @tn@ )

   if sw.0MakeHTML then do
/*    htmlds  = "HTML."@tn@".HTML" */
      htmlds  = "FAMTREE.HTML("@tn@")" /* new style                  */
      parse  var htmlds  dsonly "("
      end                              /* MakeHTML                   */

return                                 /*@ A_INIT                    */
/*
.  ----------------------------------------------------------------- */
AA_SETUP_LOG:                          /*@                           */
   if branch then call BRANCH
   address TSO

   parse value "0" with,
               log#    log.
   parse value Date("S")  Time("S")  Time("N")  with,
               ccyymmdd   sssss      hhmmss  .
   hhmmss = Space( Translate( hhmmss,' ',':' ) ,0 )
   parse var ccyymmdd  4 yrdigit 5 mm 7 dd          /* 9 12 14 maybe */
   if Pos(yrdigit,"13579") > 0 then mm = mm + 12       /* mm=24      */
   logtag = Substr("ABCDEFGHIJKLMNOPQRSTUVWX",mm,1)    /* logtag=X   */
   subid  = logtag""dd""Left(  hhmmss,4 )              /* X141743  ? */
   logf.0    = "NEW CATALOG UNIT(SYSDA) SPACE(1 1) TRACKS",
               "DSORG(PS)",
               "RECFM( V B ) LRECL( 255 ) BLKSIZE( 0 )"
   vb4k.0    = "NEW CATALOG UNIT(SYSDA) SPACE(1 5) TRACKS",
               "DSORG(PS)",
               "RECFM(V B) LRECL(4096) BLKSIZE(0)"
   vb4k.1    = "SHR"                   /* if it already exists...    */
   logdsn = "@LOG."exec_name"."subid".LIST"

   logpref = "("Branch( "ID" )")"
   call ZL_LOGMSG( logpref,
      exec_name "started by" Userid() ccyymmdd hhmmss)
   call ZL_LOGMSG( logpref  "Arg:" argline)

return                                 /*@ AA_SETUP_LOG              */
/*
.  ----------------------------------------------------------------- */
I_ISPF_FUNCS:                          /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   call IA_PROLOG                      /* Set up table and panels   -*/
                                    if \sw.0error_found then,
   call ID_DISPLAY                     /* Work the data             -*/
   call IZ_EPILOG                      /* Drop panels, close table  -*/

return                                 /*@ I_ISPF_FUNCS              */
/*
   Open the table.  If it doesn't exist, build it from AAMSTR.
   Extract all the panels and LIBDEF into place.
.  ----------------------------------------------------------------- */
IA_PROLOG:                             /*@                           */
   if branch then call BRANCH
   address ISPEXEC
             ia_tv = Trace()           /* setting at entry           */

   "LIBDEF  ISPTLIB  DATASET  ID( "isptlib" )  STACK"
   "TBSTATS" @tn@ "STATUS1(s1) STATUS2(s2)"
   if s1 > 1 then do
      zerrsm = "Table" @tn@ "not available."
      zerrlm = "Table" @tn@ "not found in the ISPTLIB library chain"
      logpref = "("Branch( "ID" )")"
      call ZL_LOGMSG( logpref  zerrsm";" zerrlm)

      cmd = "TBLGEN FT TBLNAME" @tn@ "WRITE REPLACE ",
            " ((ISPTLIB " isptlib
      address TSO (cmd)
      call ZL_LOGMSG( logpref  cmd "RC="rc )

      cmd = "TBOPEN "  @tn@  openmode.NOUPDT
      (cmd)
      call ZL_LOGMSG( logpref  cmd "RC="rc )

      ftseq    = '3f'x                 /* special key                */
      ftlastup = Date('N')             /* date of last update        */
      ftroot   = "A"

      cmd = "TBADD" @tn@ "SAVE( FTLASTUP FTROOT )"
      (cmd)
      call ZL_LOGMSG( logpref  cmd "RC="rc )

      call ZL_LOGMSG( logpref  "Added x3F row" )
      ftseq  = "A"                     /* first key                  */
      ftseql = 1                       /* sequence length            */
      ftseq2 = ftseq

      cmd = "TBADD" @tn@               /* load one row               */
      (cmd)
      call ZL_LOGMSG( logpref  cmd "RC="rc )

      if rc = 0 then,
         call ZL_LOGMSG( logpref  "Added dummy first row" )
      sw.0MakeHTML = 0                 /* why bother?                */
      end; else,
   if s2 = 1 then do                   /* table is not open          */
      cmd = "TBOPEN "  @tn@  openmode.NOUPDT
      (cmd)
      call ZL_LOGMSG( logpref  cmd "RC="rc )

      if rc > 4 then do
         zerrsm = "Table did not OPEN"
         zerrlm = "Table" @tn@ "cannot be opened due to prior",
                  "enqueues."
         call ZL_LOGMSG( logpref  zerrsm";" zerrlm"; RC="rc)
         "SETMSG  MSG(ISRZ002)"
         sw.0Error_Found = 1
         end
      else ,
         call ZL_LOGMSG( logpref  "Table" @tn@ "opened" openmode.noupdt)
      end
   else "TBTOP" @tn@
   "LIBDEF  ISPTLIB"

   /* If the existing table doesn't have FTEMAIL as a field, TBCOPY  */
   cmd = "TBQUERY" @tn@ "NAMES(NAMELIST)"
   (cmd)
   call ZL_LOGMSG( logpref  cmd "RC="rc )

   parse var namelist "(" namelist ")"
   if WordPos( "FTEMAIL",namelist ) = 0 then do
      /* call TBCOPY to rebuild the back-level table                 */
      address TSO "TBCOPY" @tn@ "TYPE FT REPLACE FROM" isptlib
      call IA_PROLOG                   /* reopen table              -*/
      return
      end                              /* back_level table           */
                   rc = Trace("O"); rc = Trace(ia_tv)
   "TBVCLEAR" @tn@                     /* zap all variables          */
   ftseq     = '3f'x                   /* special row                */
   "TBGET " @tn@ "SAVENAME( XVARS )"   /* sets FTLASTUP FTROOT       */
                                    if sw.0error_found then return
   call DEIMBED                        /* Extract ISPF assets       -*/
   dd = ""
   do Words(ddnlist)                   /* each LIBDEF DD             */
      parse value ddnlist dd  with  dd ddnlist
      @ddn   = @ddn.dd                 /* PLIB322 <- PLIB            */
      address ISPEXEC "LIBDEF  ISP"dd "LIBRARY  ID("@ddn") STACK"
   end
   ddnlist = ddnlist dd
                   rc = Trace("O"); rc = Trace(ia_tv)
   address TSO
   "NEWSTACK"
   "TBLGEN   FT  DESCRIBE     "        /* get description            */
   pull "KEYS(" keynames ")" "NAMES(" varnames ")" "SORT(" dfltsort ")"
   "DELSTACK"

   if sw.0MakeHTML       then do       /* build HTML                 */
      sw.0Error_Found = 1              /* bypass display             */
      "NEWSTACK"
      call IAH_MAKE_HTML               /*                           -*/
      "DELSTACK"
      end                              /* MakeHTML                   */

return                                 /*@ IA_PROLOG                 */
/*
   Table is open and TBTOPped.  Spin through generating <ul> groups
   based on FTSEQ and FTSEQL.  This happens AFTER the table has been
   updated and FTLASTUP set.  Remove spacing (if any) when generating
   HTML.
.  ----------------------------------------------------------------- */
IAH_MAKE_HTML:                         /*@                           */
   if branch then call BRANCH
   address ISPEXEC
                                 iah_tv = Trace()
   indent = "   "
   saveseq  = "A"
   saveseql = 1

   /* PROLOG.HTML must exist for prolog and epilog text to be added. */
   if Sysdsn( "FAMTREE.PROLOG.HTML("@tn@")") <> "OK" then,
      sw.0NoFrame  = 1

   if sw.0NoFrame =  0  then,
      call IAHA_ADD_PROLOG             /* front matter              -*/

   "TBSORT" @tn@ "FIELDS(FTSEQ,C,A)"
   "TBVCLEAR" @tn@                     /* zap all variables          */
   ftseq = " "                         /* blank                      */
   "TBSARG" @tn@ "NAMECOND(FTSEQ,GT)"
   queue Copies(indent,saveseql)"<ul>" /* start list                 */
   logpref = "("Branch( "ID" )")"
   call ZL_LOGMSG( logpref  "Queued <ul>")
   saveroot = Word( ftroot , 1 )
   do forever                          /* every row                  */
      "TBSCAN" @tn@                    /* next row                   */
      if rc > 0 then leave             /* end of table               */
      root  = Left( ftseq,1 )
      if root <> saveroot then do
         do idx = saveseql to ftseql+1 by -1
            queue   Copies(indent,idx   )"</ul>"
            call ZL_LOGMSG( logpref  "Queued </ul>")
         end                           /* ftseql                     */
         queue "<p> &nbsp;"            /* break between roots        */
         saveroot = root
         saveseql = ftseql
         end                           /* root                       */
      if ftseql =  saveseql then do    /* same level                 */
         end                           /* same level                 */
      else,
      if ftseql >  saveseql then do    /* next generation            */
         queue   Copies(indent,ftseql)"<ul>"
         call ZL_LOGMSG( logpref  "Queued <ul>")
         end                           /* next generation            */
      else,
      if ftseql <  saveseql then do    /* parent level               */
         do idx = saveseql to ftseql+1 by -1
            queue   Copies(indent,idx )"</ul>"
            call ZL_LOGMSG( logpref  "Queued </ul>")
         end                           /* idx                        */
         end                           /* down break                 */
      parse value ftseq   ftseql    with,
                  saveseq saveseql  .
      if ftseql = 2 then queue "<p>"   /* break between families     */
      vpt  = Verify( ftname,ftspcr )   /* first non-spacer           */
      ftname = Substr( ftname,vpt )    /* snip!                      */
      qline    = Copies( indent,ftseql )"<li>" ftname
      if ftbirth  <> "" then qline = qline "b."ftbirth
      if ftdeath  <> "" then qline = qline "d."ftdeath
      if ftspouse <> "" then qline = qline "m."ftspouse
      if ftweddt  <> "" then qline = qline "-" ftweddt
      if ftspbd   <> "" then qline = qline "b."ftspbd
      if ftspdd   <> "" then qline = qline "d."ftspdd
      if fttext   <> "" then qline = qline "::" fttext
      if ftemail  <> "" then qline = qline "mailto:"ftemail
      if ftspeml  <> "" then qline = qline "mailto:"ftspeml
      queue   qline
      call ZL_LOGMSG( logpref  "Queued" qline)
   end                                 /* forever                    */
                      rc = Trace("O"); rc = Trace(iah_tv)
   address TSO
   do idx = ftseql to 1 by -1
      queue   Copies(indent,idx   )"</ul>"
      call ZL_LOGMSG( logpref  "Queued </ul>")
   end                                 /* ftseql                     */

   if sw.0NoFrame = 0 then,
      call IAHE_ADD_EPILOG             /*                           -*/

   dsstat  = Sysdsn(htmlds)
   dsstat  = Pos( dsstat,"OK MEMBER NOT FOUND" ) > 0
   "ALLOC FI( @HTM ) DA( "htmlds" ) REU" vb4k.dsstat
   logpref = "("Branch( "ID" )")"
   call ZL_LOGMSG( logpref  "Writing" queued() "lines to @HTM")
   "EXECIO" queued() "DISKW @HTM (FINIS"
   "FREE  FI(@HTM)"

   call IAHS_INSCRIBE_STATS            /*                           -*/

   address ISPEXEC
   "VIEW DATASET( "htmlds" ) PROFILE( DEFAULT )"

return                                 /*@ IAH_MAKE_HTML             */
/*
   If PROLOG.HTML(@tn@) exists, insert prolog HTML.
.  ----------------------------------------------------------------- */
IAHA_ADD_PROLOG:                       /*@                           */
   if branch then call BRANCH
   address TSO

   "ALLOC FI( HTMLPRO ) DA( FAMTREE.PROLOG.HTML("@tn@") ) SHR REU"
   "EXECIO   *  DISKR HTMLPRO (FINIS"
   queue "Last updated:" ftlastup
   logpref = "("Branch( "ID" )")"
   call ZL_LOGMSG( logpref,
         queued() "lines of prolog HTML added to stack")

return                                 /*@ IAHA_ADD_PROLOG           */
/*
   If PROLOG.HTML(@tn@) exists, insert epilog HTML.
.  ----------------------------------------------------------------- */
IAHE_ADD_EPILOG:                       /*@                           */
   if branch then call BRANCH
   address TSO

   queue "</body>"
   queue "</font>"
   queue "</html>"

return                                 /*@ IAHE_ADD_EPILOG           */
/*
.  ----------------------------------------------------------------- */
IAHS_INSCRIBE_STATS:                   /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   /* Get existing stats                                             */
          /* LMINIT, LMOPEN/INPUT, LMMFIND                           */
   "LMINIT DATAID( DATAID ) DATASET( "dsonly" )"
   if rc > 0 then do
      zerrsm = "LMINIT failed"
      zerrlm = lminit.rc
      "SETMSG MSG(ISRZ002)"
      sw.error_found = "1"
      end

   "LMOPEN DATAID( "dataid" ) OPTION( INPUT )"
   if rc > 0 then do
      zerrsm = "LMOPEN failed"
      zerrlm = lmopen.rc
      "SETMSG MSG(ISRZ002)"
      sw.error_found = "1"
      end

   "LMMFIND DATAID( "dataid" ) MEMBER( "@tn@" ) STATS( YES )"
   if rc > 0 then do
      zerrsm = "LMMFIND failed"
      zerrlm = lmmfind.rc
      "SETMSG MSG(ISRZ002)"
      sw.error_found = "1"
      end

   /* Update stats                                                   */
   moddate  = Date( "S", ftlastup, "N" )  /* CcYyMmDd <- Dd mon CcYy */
   zlm4date = Translate( "CcYy/Mm/Dd", moddate, "CcYyMmDd" )
   parse value zlc4date zlm4date    with zlc4date .
   parse value zlvers   '1'         with zlvers   .
   parse value zlmod    '0'         with zlmod    .; zlmod = zlmod + 1
   parse value zlmtime  Time()      with zlmtime  .
   parse value zluser8  'FAMTREE'   with zluser8  .

   /* Replace stats                                                  */
          /* LMMSTATS, LMCLOSE, LMFREE                               */
   "LMMSTATS DATAID( "dataid" )  MEMBER( "@tn@" ) VERSION( "zlvers" )",
         "MODLEVEL(  "zlmod" )    MODTIME(  "zlmtime" )",
         "CURSIZE(   "zlcnorc" )  INITSIZE( "zlinorc" )",
         "MODRECS(   "zlmnorc" )  USER8(    "zluser8" )",
         "CREATED4(  "zlc4date" ) MODDATE4( "zlm4date" ) "

   "LMCLOSE  DATAID( "dataid" )"
   if rc > 0 then do
      zerrsm = "LMCLOSE failed"
      zerrlm = lmclose.rc
      "SETMSG MSG(ISRZ002)"
      sw.error_found = "1"
      end

   "LMFREE  DATAID( "dataid" )"
   if rc > 0 then do
      zerrsm = "LMFREE failed"
      zerrlm = lmfree.rc
      "SETMSG MSG(ISRZ002)"
      sw.error_found = "1"
      end

return                                 /*@ IAHS_INSCRIBE_STATS       */
/*
   @tn@ is set as the preferred table name.  Each family may have its
   own table.  The table is open and ready to accept data.  All panels
   are LIBDEFd and ready.
.  ----------------------------------------------------------------- */
ID_DISPLAY:                            /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   "TBVCLEAR" @tn@
   ftseq = " "                         /* blank                      */
   "TBSARG  " @tn@ "NAMECOND( FTSEQ,GT )"
   "TBSORT  " @tn@ "FIELDS( FTSEQ,C,A )"
   do forever
      disptbl  = @tn@
      "TBDISPL" @tn@ "PANEL( FAMLIST )"
       if rc > 4 then leave

      if zcmd <> "" then do
         "CONTROL DISPLAY SAVE"
         call ID0_PROCESS_CMD          /*                           -*/
         "CONTROL DISPLAY RESTORE"
         iterate
         end

      do ztdsels
         "CONTROL DISPLAY SAVE"
         select

            when sel = "C" then do
               call IDB_BUILD_TEMP     /* load current to new table -*/
               "CONTROL DISPLAY SAVE"
               call IDC_CHILDREN       /*                           -*/
               "CONTROL DISPLAY RESTORE"
               "TBEND" temp            /* flush table                */
               tidx = tidx - 1         /* expose prior table         */
               temp = "TEMP"tidx
               end                     /* Children                   */

            when sel = "P" then do
                 sw.0ForceReturn = 1   /* take me home               */
               end                     /* Parents                    */

            when sel = "U" then do
               call IDU_UPDATE         /*                           -*/
               end                     /* Update                     */

            otherwise nop

         end                           /* select                     */
         "CONTROL DISPLAY RESTORE"
         if ztdsels > 1 then "TBDISPL" @tn@
      end                              /* ztdsels                    */
      sel = ""
      if sw.0ForceReturn then leave    /* back out                   */
      "TBVCLEAR" @tn@                  /* zap all variables          */
      ftseq  = " "                     /* restore full display       */
      "TBSARG" @tn@ "NAMECOND(FTSEQ,GE)"
   end                                 /* forever                    */
   sw.0ForceReturn = 0                 /* original state             */

return                                 /*@ ID_DISPLAY                */
/*
   zcmd is populated.  Parse and execute.
.  ----------------------------------------------------------------- */
ID0_PROCESS_CMD:                       /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   parse upper var zcmd verb text
   if verb = "SORT" then do
      call ID0S_SORT                   /*                           -*/
      end                              /* SORT                       */
   else,
   if verb = "INDENT" then do
      sw.0Indented = 1
      call ID0I_INDENT                 /* add indent                -*/
      end                              /* INDENT                     */
   else,
   if verb = "DEINDENT" then do
      sw.0Indented = 0
      call ID0I_INDENT                 /* remove indent             -*/
      end                              /* NOINDENT                   */
   else,
   if verb = "ROOT" then do
      call ID0R_ROOT                   /*                           -*/
      end                              /* ROOT                       */
   else,
   if Wordpos(Left(verb,1),"F L O") > 0 then do
      "TBVCLEAR" @tn@                  /* zap all variables          */
      @z@ = Value("FTSEQ",text"*")     /* load search value          */
      "TBSARG"  @tn@ "NAMECOND(FTSEQ,EQ)"
      "TBTOP"   @tn@
      call Z_TBSCAN                    /* position to desired row   -*/

      if verb = "ONLY" then return     /* don't disp entire table    */
      end                              /* L LOCATE F FIND            */

   "TBVCLEAR" @tn@                     /* now redisplay the entire   */
   ftseq     = " "                     /* table                      */
   "TBSARG"  @tn@ "NAMECOND(FTSEQ,GE)"

return                                 /*@ ID0_PROCESS_CMD           */
/*
   Clear any existing spacer characters (DEINDENT).  If INDENT,
   restore proper number of spacer characters.
.  ----------------------------------------------------------------- */
ID0I_INDENT:                           /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   "TBTOP"    @tn@
   "TBVCLEAR" @tn@                     /* zap all variables          */
   ftseq = " "                         /* blank                      */
   "TBSARG" @tn@ "NAMECOND(FTSEQ,GT)"  /* excludes admin row         */
   logpref = "("Branch( "ID" )")"
   do forever                          /* every row                  */
      "TBSCAN" @tn@                    /* next row                   */
      if rc > 0 then leave             /* end of table               */
      vpt  = Verify( ftname,ftspcr )   /* first non-spacer           */
      ftname = Substr( ftname,vpt )    /* snip!                      */
      if sw.0Indented then ,           /* reload the spacers         */
         ftname = Copies( ftspcr,ftseql-1 ) || ftname
      "TBMOD"  @tn@
   end                                 /* forever                    */
   sw.0Changed = 1
   "TBTOP"    @tn@

return                                 /*@ ID0I_INDENT               */
/*
.  ----------------------------------------------------------------- */
ID0R_ROOT:                             /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   if text = "" | Length( text ) > 1 then do
      zerrsm = "ROOT ID required."
      zerrlm = "A one-character FTROOT value must be supplied. ",
               "A new branch will be initiated with the ID."
      "SETMSG MSG(ISRZ002)"
      logpref = "("Branch( "ID" )")"
      call ZL_LOGMSG( logpref  zerrsm ";" zerrlm )
      return
      end                              /* text is blank or too long  */
   if Pos( text,ftroot ) > 0 then do
      zerrsm = "ROOT ID exists."
      zerrlm = "ROOT" text "is already in FTROOT. ",
               "You cannot re-add an existing ROOT ID."
      "SETMSG MSG(ISRZ002)"
      call ZL_LOGMSG( logpref  zerrsm ";" zerrlm )
      return
      end                              /* text is blank or too long  */
   "TBVCLEAR" @tn@
   ftseq  = '3f'x
   "TBGET   " @tn@ "SAVENAME(XVARS)"
   ftroot = Space( ftroot text,1 )     /* add it                     */
   "TBMOD"    @tn@ "SAVE"xvars
   parse value  text 1   with,
                ftseq  sw.0changed  1 ftseq2 ftseql .
   "TBADD"    @tn@

return                                 /*@ ID0R_ROOT                 */
/*
.  ----------------------------------------------------------------- */
ID0S_SORT:                             /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   allnames = keynames varnames
   zerrlm    = ""
   sortspec  = ""
   if text   = "" then sortspec = dfltsort; else,
   do while text <> ""
      parse var text  spec text
      parse var spec  fldnm "," fldtyp "," sortdir
      parse value  fldtyp "C"  with  fldtyp  .
      parse value sortdir "A"  with sortdir  .

      if WordPos(fldnm,allnames) = 0 then do     /* wrong name       */
         zerrsm = "Sortspec error"
         zerrlm = zerrlm,
               " Incorrect name: you specified >"fldnm"<. ",
                  "The valid field names for this table are >",
                  Space(allnames,1)"<. "
         end                           /* bad fldnm                  */
      if Pos(fldtyp,"CN") = 0 then do            /* wrong type       */
         zerrsm = "Sortspec error"
         zerrlm = zerrlm,
               " Incorrect type: you specified >"fldtyp"<. ",
                  "The valid field types are >C N<."
         end
      if Pos(sortdir,"AD") = 0 then do           /* wrong dir        */
         zerrsm = "Sortspec error"
         zerrlm = zerrlm,
               " Incorrect DIR: you specified >"sortdir"<. ",
                  "The valid sort directtions are >A D<."
         end
      if zerrlm <> "" then do          /* error                      */
         zerrlm = Strip(zerrlm " Sort was not done.")
         "SETMSG MSG(ISRZ002)"
         return
         end

      sortspec = sortspec fldnm","fldtyp","sortdir
   end                                 /* text                       */

   sortspec = Space(sortspec,1)        /* squeeze out extra blanks   */
   sortspec = Translate(sortspec,","," ")       /* blanks to commas  */
   "TBSORT" @tn@  "FIELDS("sortspec")"

   if rc > 0 then do
      zerrsm  = "TBSORT failed."
      zerrlm  = exec_name "("BRANCH("ID")")",
                zerrlm
      if monitor then say,
         zerrlm
      "SETMSG  MSG(ISRZ002)"
      end

return                                 /*@ ID0S_SORT                 */
/*
   TBCREATE the TEMP table as a workspace and load the current row.
.  ----------------------------------------------------------------- */
IDB_BUILD_TEMP:                        /*@                           */
   if branch then call BRANCH
   address TSO

   tidx = tidx + 1
   temp = "TEMP"tidx
   cmd = "TBLGEN FT TBLNAME" temp,     /* build temp                 */
              " LOG WRITE REPLACE",
              " ((ISPTLIB" isptlib
   (cmd)
   logpref = "("Branch( "ID" )")"
   call ZL_LOGMSG( logpref  cmd "RC="rc )

   address ISPEXEC
   cmd = "TBOPEN "  temp  "NOWRITE"
   (cmd)
   call ZL_LOGMSG( logpref  cmd "RC="rc )

   block.temp   = ftseq                /* forbid update              */
   vpt   = Verify( ftname,ftspcr )     /* first non-spacer           */
   ftname  = Substr( ftname,vpt )      /* snip!                      */
   cmd = "TBADD" temp                  /* load to TEMP               */
   (cmd)
   call ZL_LOGMSG( logpref  cmd "RC="rc )

return                                 /*@ IDB_BUILD_TEMP            */
/*
   Given : FTSEQ of the parent
   1.  TEMP has been built and seeded with the superior line
   2.  TBSARG with FTSEQL+1 FTSEQ,GE  FTSEQ2,LE,FTSEQ||Z
   3.  transfer all existing rows to temp
   4.  add any missing FTSEQ to flesh out temp to FTSEQ||Z
.
.  FTNAME will be shown UNindented on this table.
.  ----------------------------------------------------------------- */
IDC_CHILDREN: Procedure expose,        /*@                           */
              (exposevars),
              (tk_globalvars)  log. log#
   if branch then call BRANCH
   idctv = Trace()                     /* what setting at entry?     */
   address ISPEXEC

   zseql  = ftseql + 1                 /* save ftseq and ftseql      */
   zseq   = ftseq
   "TBVCLEAR" @tn@                     /* zap all                    */
   ftseql = zseql                      /* set new values             */
   ftseq  = zseq
   ftseq2 = ftseq||'Z'                 /* upper limit                */
   base   = zseq
   "TBSARG" @tn@ "NAMECOND(FTSEQ,GE FTSEQL,LE FTSEQ2,LE)"
   if rc > 0 then do
      zerrsm = "TBSARG RC="rc ": zerrsm"
      "SETMSG MSG(ISRZ002)"
      sw.0Error_Found = 1
      return
      end
   /* Build slots for the children from ftseqA thru ftseqZ.  The first
      loop transfers the existing rows (if any), and the second loop
      fleshes the list out from ftseqZ to ftseqA until the TBADD fails
      (because there's already an existing key).
                                                                     */
   do forever
      "TBSCAN" @tn@                    /* only certain values        */
      if rc > 0 then leave             /* not found or finished      */
      vpt  = Verify( ftname,ftspcr )   /* first non-spacer           */
      ftname = Substr( ftname,vpt )    /* snip!                      */
      "TBMOD" temp                     /* add to temp table          */
      if rc > 0 then,
      if monitor then say,
         "RC="rc "on TBMOD" ftseq "to" temp
   end                                 /* forever                    */
                           rc=Trace("O"); rc=Trace(idctv)
   idx = 1                             /* start                      */
   "TBVCLEAR" @tn@
   do forever                          /* add missing rows Z-to-A    */
      ftseq  = base||Substr(ralph,idx,1)
      ftseq2 = ftseq
      ftseql = Length(ftseq)
      "TBADD" temp                     /* add to table               */
      if rc > 0 then leave             /* TBADD failed               */
      idx = idx + 1                    /* next                       */
   end                                 /* forever                    */
                           rc=Trace("O"); rc=Trace(idctv)
   call IDCD_DISPL_TEMP                /*                           -*/
   /* Flush the temporary table.                                     */
   block.temp = ''                     /* not blocked anymore...     */
   "TBEND"  temp                       /* adios                      */
   tidx = tidx - 1                     /* expose the prior temp      */
   temp = "TEMP"tidx
   if sw.0Indented then do             /*                            */
      "TBVCLEAR" @tn@                  /* zap all                    */
      ftseq = base                     /* key of main table          */
      "TBGET" @tn@                     /* sets ftseql                */
      ftname = Copies( ftspcr,ftseql-1 ) || ftname
      "TBMOD"  @tn@
      end                              /* Indented                   */

return                                 /*@ IDC_CHILDREN              */
/*
   5.  TBDISPL temp
   6.  any row that is touched:  TBMOD temp, TBMOD main (with spacer)
.  FTNAME is shown stripped of spacers.
.  ----------------------------------------------------------------- */
IDCD_DISPL_TEMP:                       /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   "TBSORT" temp "FIELDS(FTSEQ,C,A) "
   sel    = ""
   "TBVCLEAR" temp
   ftseq  = " "
   "TBSARG" temp "NAMECOND(FTSEQ,GE)"  /* display full table         */
   do forever
      disptbl  =  temp
      "TBDISPL" temp "PANEL(FAMLIST)"
       if rc > 4 then leave

      do ztdsels
         select

            when ftseq = block.temp then do    /* forbid update      */
               zerrsm = ""
               zerrlm = "You may not update the root entry on this",
                        "screen."
               "SETMSG MSG( ISRZ002 ) "
               end                     /* =block.temp                */

            when sel = "C" then do
               call IDB_BUILD_TEMP     /* recursive                 -*/
               "CONTROL DISPLAY SAVE"
               call IDC_CHILDREN       /*                           -*/
               "CONTROL DISPLAY RESTORE"
               "TBEND" temp            /* flush table                */
               tidx = tidx - 1         /* expose prior table         */
               temp = "TEMP"tidx
               end                     /* Children                   */

            when sel = "U" then do
               "CONTROL DISPLAY SAVE"
               call IDU_UPDATE         /*                           -*/
               "CONTROL DISPLAY RESTORE"
               if orig_data <> updt_data then,
                  "TBMOD" temp         /* something changed          */
               end                     /* Update                     */

            otherwise nop

         end                           /* select                     */
         if ztdsels > 1 then "TBDISPL" temp
      end                              /* ztdsels                    */
      sel = ""
   end                                 /* forever                    */

return                                 /*@ IDCD_DISPL_TEMP           */
/*
   Present the FAMUPDT panel.
.  It is possible that FTNAME still has spacer characters.  Remove any
   that still exist and be prepared to reload them if the row is
   updated.  TBMOD the main table WITH spacers.
.  ----------------------------------------------------------------- */
IDU_UPDATE:                            /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   orig_data = Space(ftname'.'ftbirth'.'ftdeath'.'ftspouse,
                    '.'ftweddt'.'fttext,
                    '.'ftspbd'.'ftspdd'.'ftemail'.'ftspeml, 0)
   /* Strip out all '41'x chars from FTNAME before processing.       */
   vpt   = Verify( ftname,ftspcr )     /* find first non-spacer      */
   ftname = Substr( ftname,vpt )       /* snip!                      */
   do forever
      "DISPLAY PANEL(FAMUPDT)"
      if rc = 8 then leave
   end                                 /* forever                    */
   /* Restore missing spacer chars.                                  */
   if sw.0Indented then,
      ftname = Copies( ftspcr,ftseql-1 ) || ftname
   updt_data = Space(ftname'.'ftbirth'.'ftdeath'.'ftspouse,
                    '.'ftweddt'.'fttext,
                    '.'ftspbd'.'ftspdd'.'ftemail'.'ftspeml, 0)
   if orig_data <> updt_data then do
      "TBMOD" @tn@                     /* something changed          */
      sw.0Changed = 1
      logpref = "("Branch( "ID" )")"
      call ZL_LOGMSG( logpref  "TBMOD" ftseq ftname ftbirth )
      zerrsm = ftseq "Updated"
      zerrlm = ftseq"="ftname ftbirth ftdeath
      "SETMSG MSG(ISRZ002)"
      end

return                                 /*@ IDU_UPDATE                */
/*
.  ----------------------------------------------------------------- */
IZ_EPILOG:                             /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   if noupdt then sw.0Changed = 0      /* changes disallowed         */
   if sw.0Changed then do              /* update special row         */
      "TBVCLEAR" @tn@
      ftseq   = '3f'x
      "TBGET   " @tn@ "SAVENAME(XVARS)" /* incl FTLASTUP             */
      parse var xvars "(" xvars ")"
      ftlastup = Date('N')             /* dd Mon ccyy                */
      if WordPos( "FTLASTUP",xvars ) = 0 then,
         xvars = xvars "FTLASTUP"
      "TBMOD   " @tn@ "SAVE("xvars")"  /* put it back w new date     */
      logpref = "("Branch( "ID" )")"
      call ZL_LOGMSG( logpref  "FTLASTUP changed to" ftlastup )
      if sw.0Indented then do
         sw.0Indented = 0
         call ID0I_INDENT              /* remove indentation        -*/
         end
      end                              /* update special row         */

   "LIBDEF  ISPTABL  DATASET  ID( "isptabl" )  STACK"
   if sw.0Changed then "TBCLOSE" @tn@  /* save                       */
                  else "TBEND  " @tn@  /* don't save                 */
   "LIBDEF  ISPTABL"

   dd = ""
   do Words(ddnlist)                   /* each LIBDEF DD             */
      parse value ddnlist dd  with  dd ddnlist
      @ddn   = @ddn.dd                 /* PLIB322 <- PLIB            */
      "LIBDEF  ISP"dd
      address TSO "FREE  FI("@ddn")"
   end
   ddnlist = ddnlist dd

return                                 /*@ IZ_EPILOG                 */
/*
   Dump the table to a flat file for transport.
.  ----------------------------------------------------------------- */
U_DUMP_TBL:                            /*@                           */
   if branch then call BRANCH
   address TSO

   "FLTTBL" @tn@ "IN" isptlib,
            "SORT FTSEQ,CH,A   ADD 200 ((TRACE" tv

   address ISPEXEC
   "VIEW DATASET(FLATTBLS."@tn@") PROFILE(DEFAULT)"

return                                 /*@ U_DUMP_TBL                */
/*
.  ----------------------------------------------------------------- */
LOCAL_PREINIT:                         /*@ customize opts            */
   address TSO

   parse value KEYWD("ISPTLIB")             with,
               isptlib   .

   parse value KEYWD("ISPTABL")  isptlib    with,
               isptabl   . /* if ISPTLIB but not ISPTABL, use ISPTLIB*/

   parse value isptlib  isptabl             with,
               isptlib   . /* if ISPTABL but not ISPTLIB, use ISPTABL*/

   lminit.   = "Unknown return code"
   lminit.8 =  "Data set or file not allocated because DDname not",
               "found or Data set or file organization not supported."
   lminit.12 = "Invalid parameter value "
   lminit.16 = "Truncation or translation error in accessing dialog",
               "variables."
   lminit.20 = "Severe error "

   lmopen.   = "Unknown return code"
   lmopen.8  = "Open failed because Data set record format not",
               "supported by ISPF "
   lmopen.10 = "No data set associated with the dataid "
   lmopen.12 = "Invalid parameter value:  Data set is already open",
               "or Cannot open data set allocated 'SHR' for output"
   lmopen.16 = "Truncation or translation error in storing defined",
               "variables "
   lmopen.20 = "Severe error"

   lmmfind.   = "Unknown return code"
   lmmfind.4  = "Member not available"
   lmmfind.8  = "Member not found "
   lmmfind.10 = "No data set or file associated with the given dataid"
   lmmfind.12 = "Data set or file not open or not open for input",
                "because Data set is not an ISPF library or MVS",
                "partitioned data set or Invalid parameter value"
   lmmfind.16 = "Truncation or translation error in accessing dialog",
                "variables "
   lmmfind.20 = "Severe error "

   lmmstats.   = "Unknown return code"
   lmmstats.4  = "No members match pattern or No member in data set"
   lmmstats.8  = "Member not found "
   lmmstats.10 = "No data set associated with the given dataid "
   lmmstats.12 = "Invalid parameter value:  Data set is not open or is",
                 "not partitioned "
   lmmstats.20 = "Severe error "

   lmclose.    = "Unknown return code"
   lmclose.8   = "Data set is not open "
   lmclose.10  = "No data set associated with the given data id "
   lmclose.20  = "Severe error "

   lmfree.   = "Unknown return code"
   lmfree.8  = "Free data set or file failed "
   lmfree.10 = "No data set or file associated with dataid "
   lmfree.20 = "Severe error "

return                                 /*@ LOCAL_PREINIT             */
/*   subroutines below LOCAL_PREINIT are not selected by SHOWFLOW    */
/*
   Parse out the embedded components at the back of the source code.
.  ----------------------------------------------------------------- */
DEIMBED: Procedure expose,             /*@                           */
   (tk_globalvars)  ddnlist  @ddn.  daid.
   ddd_tv = Trace()                    /* at entry                   */

   address TSO

   fb80po.0  = "NEW DEL UNIT(SYSDA) SPACE(1 5) TRACKS DIR(40)",
                   "RECFM(F B) LRECL(80) BLKSIZE(0)"
   fb80po.1  = "SHR"
   parse value ""   with  ddnlist @ddn.  daid.

   lastln   = sourceline()
   currln   = lastln                   /*                            */
   if Left(sourceline(currln),2) <> "*/" then return

   currln = currln - 1                 /* previous line              */
   "NEWSTACK"
   address ISPEXEC
   do while sourceline(currln) <> "/*"
      text = sourceline(currln)        /* save with a short name !   */
      if Left(text,3) = ")))" then do  /* package the queue          */
                          rc=Trace('O');  rc=Trace(ddd_tv)
         parse var text ")))" ddn mbr .   /* PLIB PANL001  maybe     */
         if length(ddn) > 4 then do    /* data, not ISPF             */
            call DESPOOL               /*                           -*/
            currln = currln - 1        /* previous line              */
            iterate
            end
         if Pos(ddn,ddnlist) = 0 then do  /* doesn't exist           */
            ddnlist = ddnlist ddn      /* keep track                 */
            @ddn = ddn || Random(999)  /* PLIB322 maybe              */
            @ddn.ddn = @ddn            /* @ddn.PLIB = PLIB322        */
            address TSO "ALLOC FI("@ddn") REU" fb80po.0
            "LMINIT DATAID(DAID) DDNAME("@ddn")"
            daid.ddn = daid
            end
         daid = daid.ddn
         "LMOPEN DATAID("daid") OPTION(OUTPUT)"
         do queued()
            parse pull line
            "LMPUT DATAID("daid") MODE(INVAR) DATALOC(LINE) DATALEN(80)"
         end
         "LMMADD DATAID("daid") MEMBER("mbr")"
         "LMCLOSE DATAID("daid")"
         end                           /* package the queue          */
      else push text                   /* onto the top of the stack  */
      currln = currln - 1              /* previous line              */
   end                                 /* while                      */
   address TSO "DELSTACK"
   return                              /* deimbed                    */
/*
   Subroutine of DEIMBED for non-ISPF data.
   Given : the stack, ddn, and mbr
.  ----------------------------------------------------------------- */
DESPOOL:                               /*@                           */
   address TSO

   if monitor then say,
      "DESPOOL DDN="ddn  "MBR="mbr queued() "lines"
   if Sysdsn(ddn".DATA") <> "OK" then,
      "ALLOC FI("ddn") DA("ddn".DATA) REU" fb80po.0
   "ALLOC FI("ddn") DA("ddn".DATA("mbr")) SHR REU"
   "EXECIO" queued() "DISKW" ddn "(FINIS"
   "DELSTACK"
   "NEWSTACK"                          /* re-establish               */

return                                 /*@ DESPOOL                   */

return                                 /*@ DEIMBED                   */
/*
     Find where code was run from.  It assumes cataloged data sets.

     Original by Doug Nadel
     With SWA code lifted from Gilbert Saint-flour's SWAREQ exec
.  ----------------------------------------------------------------- */
FIND_ORIGIN: Procedure                 /*@                           */
answer="* UNKNOWN *"                   /* assume disaster            */
Parse Source . . name dd ds .          /* get known info             */
Call listdsi(dd "FILE")                /* get 1st ddname from file   */
Numeric digits 10                      /* allow up to 7FFFFFFF       */
If name = "?" Then                     /* if sequential exec         */
  answer="'"ds"'"                      /* use info from parse source */
Else                                   /* now test for members       */
  If sysdsn("'"sysdsname"("name")'")="OK" Then /* if in 1st ds       */
     answer="'"sysdsname"("name")'"    /* go no further              */
  Else                                 /* hooboy! Lets have some fun!*/
    Do                                 /* scan tiot for the ddname   */
      tiotptr=24+ptr(12+ptr(ptr(ptr(16)))) /* get ddname array       */
      tioelngh=c2d(stg(tiotptr,1))     /* nength of 1st entry        */
      Do Until tioelngh=0 | tioeddnm = dd /* scan until dd found     */
        tioeddnm=strip(stg(tiotptr+4,8)) /* get ddname from tiot     */
        If tioeddnm <> dd Then         /* if not a match             */
          tiotptr=tiotptr+tioelngh     /* advance to next entry      */
        tioelngh=c2d(stg(tiotptr,1))   /* length of next entry       */
      End
      If dd=tioeddnm Then,             /* if we found it, loop through
                                          the data sets doing an swareq
                                          for each one to get the
                                          dsname                     */
        Do Until tioelngh=0 | stg(4+tiotptr,1)<> " "
          tioejfcb=stg(tiotptr+12,3)
          jfcb=swareq(tioejfcb)        /* convert SVA to 31-bit addr */
          dsn=strip(stg(jfcb,44))      /* dsname JFCBDSNM            */
          vol=storage(d2x(jfcb+118),6) /* volser JFCBVOLS (not used) */
          If sysdsn("'"dsn"("name")'")='OK' Then,  /* found it?      */
            Leave                      /* we is some happy campers!  */
          tiotptr=tiotptr+tioelngh     /* get next entry             */
          tioelngh=c2d(stg(tiotptr,1)) /* get entry length           */
        End
      answer="'"dsn"("name")'"         /* assume we found it         */
    End
Return answer                          /*@ FIND_ORIGIN               */
/*
.  ----------------------------------------------------------------- */
ptr:  Return c2d(storage(d2x(Arg(1)),4))          /*@                */
/*
.  ----------------------------------------------------------------- */
stg:  Return storage(d2x(Arg(1)),Arg(2))          /*@                */
/*
.  ----------------------------------------------------------------- */
SWAREQ:  Procedure                     /*@                           */
If right(c2x(Arg(1)),1) \= 'F' Then    /* SWA=BELOW ?                */
  Return c2d(Arg(1))+16                /* yes, return sva+16         */
sva = c2d(Arg(1))                      /* convert to decimal         */
tcb = c2d(storage(21c,4))              /* TCB PSATOLD                */
tcb = ptr(540)                         /* TCB PSATOLD                */
jscb = ptr(tcb+180)                    /* JSCB TCBJSCB               */
qmpl = ptr(jscb+244)                   /* QMPL JSCBQMPI              */
qmat = ptr(qmpl+24)                    /* QMAT QMADD                 */
Do While sva>65536
  qmat = ptr(qmat+12)                  /* next QMAT QMAT+12          */
  sva=sva-65536                        /* 010006F -> 000006F         */
End
return ptr(qmat+sva+1)+16              /*@ SWAREQ                    */
/*
   The table is positioned to find a row and the argument is set.
.  ----------------------------------------------------------------- */
Z_TBSCAN:                              /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   "TBSCAN" @tn@ "ROWID(LASTFND) POSITION(LASTCRP)"
                      /* set LASTFND and LASTCRP if successful       */
   if rc = 8 then do                   /* not found                  */
      zerrsm = "Not found"
      zerrlm = "No rows found to match" text
      zerrlm = exec_name "("BRANCH("ID")")",
               zerrlm
      address ISPEXEC "SETMSG  MSG(ISRZ002)"
      return
      end                              /* not found                  */
   "TBSKIP" @tn@ "ROW("lastfnd") NOREAD"    /* position to LASTFND   */

return                                 /*@ Z_TBSCAN                  */
/*
.  ----------------------------------------------------------------- */
ZB_SAVELOG:                            /*@                           */
   if branch then call BRANCH
   address TSO

   if Symbol("LOG#") = "LIT" then return          /* not yet set     */

   "ALLOC FI( @LOG ) DA( "logdsn" ) REU" logf.0
   "EXECIO" log# "DISKW @LOG (STEM LOG. FINIS"
   "FREE  FI(@LOG)"

return                                 /*@ ZB_SAVELOG                */
/*
.  ----------------------------------------------------------------- */
ZL_LOGMSG: Procedure expose,           /*@                           */
   (tk_globalvars)  log. log#
   rc = Trace("O")
   address TSO

   parse arg msgtext
   parse value  log#+1  msgtext     with,
                zz      log.zz    1  log#   .

   if monitor then say,
      msgtext

return                                 /*@ ZL_LOGMSG                 */
/*
.  ----------------------------------------------------------------- */
HELP:                                  /*@                           */
address TSO;"CLEAR"
if helpmsg <> "" then say helpmsg
ex_nam = Left(exec_name,8)             /* predictable size           */
say "                                                                          "
say "  "ex_nam"      aids in collecting data on familial relationships as for  "
say "                genealogy.                                                "
say "                                                                          "
say "  Syntax:   "ex_nam" tblnm                                      (Required)"
say "                     LOG                                                  "
say "                     HTML                                                 "
say "                     FLATTEN                                              "
say "                ((   ISPTLIB  intblds                           (Defaults)"
say "                     ISPTABL  outtblds                          (Defaults)"
say "                                                                          "
say "            tblnm     identifies the table to be used.  Name it for the   "
say "                      family whose data is being collected.               "
say "                                                                          "
say "            LOG       if specified, causes the log file to be kept at     "
say "                      process-end rather than discarded.  In case of      "
say "                      error, the log file is kept unconditionally.        "
say "                                                                          "
say "                                                      more...             "
"NEWSTACK"; pull ; "CLEAR" ; "DELSTACK"
say "                                                                          "
say "            HTML      if specified, builds an HTML fragment consisting of "
say "                      <ul>-<li>-</ul> tags with associated data from the  "
say "                      file. HTML and FLATTEN are mutually exclusive.      "
say "                                                                          "
say "                For prolog HTML, <userid>.FAMTREE.PROLOG.HTML(<tblnm>)    "
say "                (where <tblnm> is the name of the table being processed)  "
say "                must be available at execution time.  This will be        "
say "                prepended to the generated HTML.  Epilog text, always the "
say "                same, will be appended if the PROLOG dataset exists.      "
say "                                                                          "
say "                                                      more...             "
"NEWSTACK"; pull ; "CLEAR" ; "DELSTACK"
say "                                                                          "
say "            FLATTEN   if specified, calls FLTTBL to copy the current table"
say "                      as a VB4K file typical for FLTTBL output.  HTML and "
say "                      FLATTEN are mutually exclusive.                     "
say "                                                                          "
say "            intblds   specifies the library containing <tblnm>.  If not   "
say "                      specified, the current ISPTABL is used.             "
say "                                                                          "
say "            outtblds  specifies the library on which to write the updated "
say "                      <tblnm>.  If not specified, the intblds is used.    "
say "                                                                          "
say "            If neither <intblds> nor <outtblds> is specified, DFLTTLIB    "
say "            will be called to supply a value for both.                    "
say "                                                                          "
say "                                                      more...             "
"NEWSTACK"; pull ; "CLEAR" ; "DELSTACK"
say "                                                                          "
say "   Debugging tools provided include:                                      "
say "                                                                          "
say "        MONITOR:  displays key information throughout processing.         "
say "                                                                          "
say "        NOUPDT:   by-pass all update logic.                               "
say "                                                                          "
say "        BRANCH:   show all paragraph entries.                             "
say "                                                                          "
say "        TRACE tv: will use value following TRACE to place the             "
say "                  execution in REXX TRACE Mode.                           "
say "                                                                          "
say "                                                                          "
say "   Debugging tools can be accessed in the following manner:               "
say "                                                                          "
say "        TSO "ex_nam"  parameters     ((  debug-options                    "
say "                                                                          "
say "   For example:                                                           "
say "                                                                          "
say "        TSO "ex_nam"  (( MONITOR TRACE ?R                                 "

if sysvar("SYSISPF") = "ACTIVE" then,
   address ISPEXEC "CONTROL DISPLAY REFRESH"
exit                                   /*@ HELP                      */
/*
.  ----------------------------------------------------------------- */
BRANCH: Procedure expose,              /*@                           */
        sigl exec_name
   rc = trace("O")                     /* we do not want to see this */
   arg brparm .

   origin = sigl                       /* where was I called from ?  */
   do currln = origin to 1 by -1       /* inch backward to label     */
      if Right(Word(Sourceline(currln),1),1) = ":" then do
         parse value sourceline(currln) with pgfname ":" .  /* Label */
         leave ; end                   /*                name        */
   end                                 /* currln                     */

   select
      when brparm = "NAME" then return(pgfname) /* Return full name  */
      when brparm = "ID"      then do           /* wants the prefix  */
         parse var pgfname pgfpref "_" .        /* get the prefix    */
         return(pgfpref)
         end                           /* brparm = "ID"              */
      otherwise
         say left(sigl,6) left(pgfname,40) exec_name "Time:" time("L")
   end                                 /* select                     */

return                                 /*@ BRANCH                    */
/*
.  ----------------------------------------------------------------- */
DUMP_QUEUE:                            /*@ Take whatever is in stack */
   rc = trace("O")                     /*  and write to the screen   */
   address TSO
   arg mode .

   "QSTACK"                            /* how many stacks?           */
   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */
   if stk2dump = 0 & queued() = 0 then return
   if mode <> "QUIET" then,
   say "Total Stacks" rc ,             /* rc = #of stacks            */
    "   Begin Stacks" tk_init_stacks , /* Stacks present at start    */
    "   Excess Stacks to dump" stk2dump

   do dd = rc to tk_init_stacks by -1  /* empty each one.            */
      if mode <> "QUIET" then,
      say "Processing Stack #" dd "   Total Lines:" queued()
      do queued();parse pull line;say line;end /* pump to the screen */
      "DELSTACK"                       /* remove stack               */
   end                                 /* dd = 1 to rc               */

return                                 /*@ DUMP_QUEUE                */
/* Handle CLIST-form keywords             added 20020513
.  ----------------------------------------------------------------- */
CLKWD: Procedure expose info           /*@ hide all except info      */
   arg kw
   kw = kw"("                          /* form is 'KEY(DATA)'        */
   kw_pos = Pos(kw,info)               /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   rtpt   = Pos(") ",info" ",kw_pos)   /* locate end-paren           */
   slug   = Substr(info,kw_pos,rtpt-kw_pos+1)     /* isolate         */
   info   = Delstr(info,kw_pos,rtpt-kw_pos+1)     /* excise          */
   parse var slug (kw)     slug        /* drop kw                    */
   slug   = Reverse(Substr(Reverse(Strip(slug)),2))
return slug                            /*@CLKWD                      */
/* Handle multi-word keys 20020513
.  ----------------------------------------------------------------- */
KEYWD: Procedure expose info           /*@ hide all vars, except info*/
   arg kw
   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   kw_val = word(info,kw_pos+Words(kw))/* get the next word          */
   info   = Delword(info,kw_pos,2)     /* remove both                */
return kw_val                          /*@ KEYWD                     */
/*
.  ----------------------------------------------------------------- */
KEYPHRS: Procedure expose,             /*@                           */
         info helpmsg exec_name        /*  except these three        */
   arg kp
   wp    = wordpos(kp,info)            /* where is it?               */
   if wp = 0 then return ""            /* not found                  */
   front = subword(info,1,wp-1)        /* everything before kp       */
   back  = subword(info,wp+1)          /* everything after kp        */
   parse var back dlm back             /* 1st token must be 2 bytes  */
   if length(dlm) <> 2 then            /* Must be two bytes          */
      helpmsg = helpmsg,
         "Invalid length for delimiter("dlm") with KEYPHRS("kp")"
   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/
      helpmsg = helpmsg,
         "No matching second delimiter("dlm") with KEYPHRS("kp")"
   if helpmsg <> "" then call HELP     /* Something is wrong         */
   parse var back kpval (dlm) back     /* get everything b/w delim   */
   info =  front back                  /* restore remainder          */
return Strip(kpval)                    /*@ KEYPHRS                   */
/*
.  ----------------------------------------------------------------- */
NOVALUE:                               /*@                           */
   say exec_name "raised NOVALUE at line" sigl
   say " "
   say "The referenced variable is" condition("D")
   say " "
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ NOVALUE                   */
/*
.  ----------------------------------------------------------------- */
SHOW_SOURCE:                           /*@                           */
   call DUMP_QUEUE                     /* Spill contents of stacks  -*/
   if sourceline() <> "0" then         /* to screen                  */
      say sourceline(zsigl)
   rc =  trace("?R")
   nop
   exit                                /*@ SHOW_SOURCE               */
/*
.  ----------------------------------------------------------------- */
SS: Procedure                          /*@ Show Source               */
   arg  ssbeg  ssend  .
   if ssend = "" then ssend = 10
   if \datatype(ssbeg,"W") | \datatype(ssend,"W") then return
   ssend = ssbeg + ssend
   do ssii = ssbeg to ssend ; say Strip(sourceline(ssii),'T') ; end
return                                 /*@ SS                        */
/*
.  ----------------------------------------------------------------- */
SWITCH: Procedure expose info          /*@                           */
   arg kw
   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */
   if sw_val then                      /* exists                     */
      info = Delword(info,Wordpos(kw,info),1) /* remove it           */
return sw_val                          /*@ SWITCH                    */
/*
.  ----------------------------------------------------------------- */
SYNTAX:                                /*@                           */
   errormsg = exec_name "encountered REXX error" rc "in line" sigl":",
                        errortext(rc)
   say errormsg
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ SYNTAX                    */
/*
   Can call TRAPOUT.
.  ----------------------------------------------------------------- */
TOOLKIT_INIT:                          /*@                           */
   address TSO
   info = Strip(opts,"T",")")          /* clip trailing paren        */

   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,
                     as_invokt  cmd_env  addr_spc  usr_tokn

   parse value "" with  tv  helpmsg  zerrlm  .
   parse value 0   "ISR00000  YES"     "Error-Press PF1"    with,
               sw.  zerrhm    zerralrm  zerrsm

   if SWITCH("TRAPOUT") then do
      "TRAPOUT" exec_name parms "(( TRACE R" info
      exit
      end                              /* trapout                    */

   sw.nested    = sysvar("SYSNEST") = "YES"
   sw.batch     = sysvar("SYSENV")  = "BACK"
   sw.inispf    = sysvar("SYSISPF") = "ACTIVE"

   if Word(parms,1) = "?" then call HELP /* I won't be back          */

   "QSTACK" ; tk_init_stacks = rc      /* How many stacks?           */

   parse value SWITCH("BRANCH") SWITCH("MONITOR") SWITCH("NOUPDT") with,
               branch           monitor           noupdt    .

   parse value mvsvar("SYSNAME") sysvar("SYSNODE") with,
               #tk_cpu           node          .

   parse value KEYWD("TRACE")  "N"    with   tv  .
   tk_globalvars = "exec_name  tv  helpmsg  sw.  zerrhm  zerralrm ",
                   "zerrsm  zerrlm  tk_init_stacks  branch  monitor ",
                   "noupdt"

   call LOCAL_PREINIT                  /* for more opts             -*/

return                                 /*@ TOOLKIT_INIT              */
/*
))) PLIB     FAMLIST   Scrollable list of all principals
)ATTR
  % TYPE( TEXT   ) INTENS( HIGH ) SKIP( ON )
  + TYPE( TEXT   ) INTENS( LOW  ) SKIP( ON )
  _ TYPE( INPUT  ) INTENS( HIGH ) CAPS( ON  )
  ! TYPE( OUTPUT ) INTENS( HIGH ) SKIP( ON )
  @ TYPE( OUTPUT ) INTENS( LOW  ) SKIP( ON )
)BODY EXPAND(||) WIDTH(&ZSCREENW)
%|-| Contents of table@disptbl   +|-|
%Command ===>_ZCMD
+                                                            %Scroll ===>_ZAMT+
+  / Select one or more rows or command%SORT,+%L+(Locate),%ONLY+or%ROOT+
+ /                                      See HELP for details.
+V%Sequence         +Birth dt +Name
)MODEL ROWS( SCAN )
_z@ftseq            !ftbirth  !ftname
)INIT
  .ZVARS = '(SEL)'
  .HELP = FAMLISTH
)REINIT
)PROC
  IF (.PFKEY = 'PF05')
      &PFKEY = 'F5'
      .RESP = END
)END
))) PLIB     FAMLISTH  HELP for FAMLIST Primary display
)ATTR
  % TYPE( TEXT   ) INTENS( HIGH ) SKIP( ON )
  + TYPE( TEXT   ) INTENS( LOW  ) SKIP( ON )
  _ TYPE( INPUT  ) INTENS( HIGH )
  ! TYPE( OUTPUT ) INTENS( HIGH ) SKIP( ON )
  @ TYPE( OUTPUT ) INTENS( LOW  ) SKIP( ON )
  } AREA( SCRL   )         EXTEND( ON )
)BODY EXPAND(||) WIDTH( &ZSCREENW )
%TUTORIAL |-| +Contents of table!disptbl %|-| TUTORIAL
%Command ===>_ZCMD
                                                                               +
}hlptxt                                                                        }
)AREA HLPTXT
+
+   Select one or more rows using line commands
+        %C+to display and update the%children+of this person, or
+        %U+to directly update this entry.
+
+   Alternatively, you may enter%SORT <sortspec>+ on the command line to
+   re-sort the display.  If <sortspec> is empty, the default sort sequence
+  %FIELDS(FTSEQ,C,A)+will be used.  The valid fieldnames for <sortspec> are
+   !keynames!varnames
+
+   Command%L+(Locate) with a sequence value will position the display to that
+   value if it exists.
+
+   Command%ONLY+with a sequence value will position the display to that value
+   if it exists and exclude all non-matching rows.  This is a good way to
+   focus on a single family line.
+
+   Command%ROOT+with a one-character ID to start a new line other than the
+   default%A+if the main table is displayed.  This allows multiple family
+   lines to be in the same table.
+
+   To indent, command%INDENT+will indent all names in accordance with
+   their place in the hierarchy.  Command%DEINDENT+will remove all
+   indentation.
+
)PROC
   &ZCONT = FAMLISTH
   &ZUP   = FAMLISTH
)END
))) PLIB     FAMUPDT   ..
)ATTR
  % TYPE( TEXT   ) INTENS( HIGH ) SKIP( ON )
  + TYPE( TEXT   ) INTENS( LOW  ) SKIP( ON )
  _ TYPE( INPUT  ) INTENS( LOW  ) CAPS( ON  )
  @ TYPE( TEXT   ) INTENS( HIGH ) COLOR( YELLOW )
  ! TYPE( INPUT  ) INTENS( HIGH ) CAPS( OFF )
  # TYPE( OUTPUT ) INTENS( HIGH )
)BODY EXPAND(||) WIDTH(&ZSCREENW)
@|-|% Update record contents for Sequence#ftseq    @|-|
%COMMAND ===>_ZCMD
                                                              %SCROLL ===>_ZAMT+
+        Name!ftname
+      Email:!ftemail
+  Birth Date!ftbirth +  ccyymmdd
+  Death Date!ftdeath +  ccyymmdd
+      Spouse!ftspouse                                 +B:!ftspbd  +D:!ftspdd  +
                                 Email:!ftspeml
+Married Date!ftweddt +  ccyymmdd
+        Text!fttext

+
)INIT
  .HELP = FAMUPDTH
)PROC
)END
))) PLIB     FAMUPDTH  ..
)ATTR
  % TYPE( TEXT   ) INTENS( HIGH ) SKIP( ON )
  + TYPE( TEXT   ) INTENS( LOW  ) SKIP( ON )
  _ TYPE( INPUT  ) INTENS( HIGH )
  ! TYPE( OUTPUT ) INTENS( HIGH ) SKIP( ON )
  @ TYPE( OUTPUT ) INTENS( LOW  ) SKIP( ON )
)BODY EXPAND(||) WIDTH(&ZSCREENW)
%TUTORIAL |-| Update record contents for Sequence |-| TUTORIAL
%Next Selection ===>_ZCMD
+
+
    Enter whatever data is available for the named sequence value.  Values left
    empty will be saved as empty.  Dates are 4-digit year plus 2-digit month
    plus 2-digit day with no intervening characters:%ccyymmdd+  This enables
    dates to be sorted coherently.
+
)PROC
   &ZCONT = FAMUPDTH
   &ZUP   = FAMUPDTH
)END
*/
